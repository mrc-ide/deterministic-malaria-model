## Automatically generated by odin 1.1.15 - do not edit
odin_model_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "odin_model_rhs_dde",
      rhs_desolve = "odin_model_rhs_desolve",
      initmod_desolve = "odin_model_initmod_desolve",
      output_dde = "odin_model_output_dde"),
    dll = "ICDMM",
    user = c("aD", "age", "age_20_factor", "age_rate", "age05", "age20l",
             "age20u", "age59", "b0", "b1", "betaL", "bites_Bed",
             "bites_Indoors", "cD", "chi", "cT", "cU", "d_IRS0", "d_ITN0",
             "d1", "dB", "dCA", "dCM", "dE", "dEL", "delayGam", "delayMos",
             "den", "dID", "dLL", "dPL", "eta", "fD0", "foi_age", "ft",
             "gamma1", "gammaD", "gammaL", "het_wt", "IB0", "IC0", "ID0",
             "init_A", "init_D", "init_EL", "init_Ev", "init_IB", "init_ICA",
             "init_ICM", "init_ID", "init_Iv", "init_LL", "init_P",
             "init_PL", "init_S", "init_Sv", "init_T", "init_U", "irs_cov",
             "IRS_interval", "irs_loss", "itn_cov", "ITN_interval",
             "ITN_IRS_on", "itn_loss", "kB", "kC", "kD", "mu0", "muEL",
             "muLL", "muPL", "mv0", "na", "nh", "num_int", "omega", "p10",
             "p2", "phi0", "phi1", "pi", "PM", "Q0", "r_IRS0", "r_ITN0",
             "r_ITN1", "rA", "rD", "rel_foi", "rP", "rT", "rU", "ssa0",
             "ssa1", "ssa2", "ssa3", "ssb1", "ssb2", "ssb3", "tau1", "tau2",
             "theta_c", "uB", "uCA", "uD", "x_I"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("odin_model_rhs_dde", package = "ICDMM")
        .C("odin_model_rhs_desolve", package = "ICDMM")
        .C("odin_model_initmod_desolve", package = "ICDMM")
        .C("odin_model_output_dde", package = "ICDMM")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("odin_model_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "ICDMM")
    },

    update_metadata = function() {
      meta <- .Call("odin_model_metadata", private$ptr,
                    PACKAGE = "ICDMM")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("odin_model_create", user, PACKAGE = "ICDMM")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/odin_model.json", mustWork = TRUE,
                             package = "ICDMM")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("odin_model_set_user", private$ptr, user, PACKAGE = "ICDMM")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("odin_model_initial_conditions", private$ptr, t, PACKAGE = "ICDMM")
    },

    rhs = function(t, y) {
      .Call("odin_model_rhs_r", private$ptr, t, y, PACKAGE = "ICDMM")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("odin_model_contents", private$ptr, PACKAGE = "ICDMM")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_delay(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


odin_model <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("odin_model")
  odin_model_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(odin_model) <- "odin_generator"
attr(odin_model, "generator") <- odin_model_
odin_model_emanators_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "odin_model_emanators_rhs_dde",
      rhs_desolve = "odin_model_emanators_rhs_desolve",
      initmod_desolve = "odin_model_emanators_initmod_desolve",
      output_dde = "odin_model_emanators_output_dde"),
    dll = "ICDMM",
    user = c("aD", "age", "age_20_factor", "age_rate", "age05", "age20l",
             "age20u", "age59", "b0", "b1", "betaL", "bites_Bed",
             "bites_Indoors", "cD", "cT", "cU", "d_EM0", "d1", "dB", "dCA",
             "dCM", "dE", "dEL", "delayGam", "delayMos", "den", "dID", "dLL",
             "dPL", "em_cov", "EM_interval", "em_loss", "EM_on", "eta",
             "fD0", "foi_age", "ft", "gamma1", "gammaD", "gammaL", "het_wt",
             "IB0", "IC0", "ID0", "init_A", "init_D", "init_EL", "init_Ev",
             "init_IB", "init_ICA", "init_ICM", "init_ID", "init_Iv",
             "init_LL", "init_P", "init_PL", "init_S", "init_Sv", "init_T",
             "init_U", "itn_cov", "ITN_interval", "ITN_on", "kB", "kC", "kD",
             "mu0", "muEL", "muLL", "muPL", "mv0", "na", "nh", "omega",
             "p10", "p2", "phi0", "phi1", "pi", "PM", "Q0", "r_EM0", "rA",
             "rD", "rel_foi", "rP", "rT", "rU", "ssa0", "ssa1", "ssa2",
             "ssa3", "ssb1", "ssb2", "ssb3", "surv_bioassay", "tau1", "tau2",
             "theta_c", "uB", "uCA", "uD", "x_I"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("odin_model_emanators_rhs_dde", package = "ICDMM")
        .C("odin_model_emanators_rhs_desolve", package = "ICDMM")
        .C("odin_model_emanators_initmod_desolve", package = "ICDMM")
        .C("odin_model_emanators_output_dde", package = "ICDMM")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("odin_model_emanators_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "ICDMM")
    },

    update_metadata = function() {
      meta <- .Call("odin_model_emanators_metadata", private$ptr,
                    PACKAGE = "ICDMM")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("odin_model_emanators_create", user, PACKAGE = "ICDMM")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/odin_model_emanators.json", mustWork = TRUE,
                             package = "ICDMM")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("odin_model_emanators_set_user", private$ptr, user, PACKAGE = "ICDMM")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("odin_model_emanators_initial_conditions", private$ptr, t, PACKAGE = "ICDMM")
    },

    rhs = function(t, y) {
      .Call("odin_model_emanators_rhs_r", private$ptr, t, y, PACKAGE = "ICDMM")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("odin_model_emanators_contents", private$ptr, PACKAGE = "ICDMM")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_delay(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


odin_model_emanators <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("odin_model_emanators")
  odin_model_emanators_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(odin_model_emanators) <- "odin_generator"
attr(odin_model_emanators, "generator") <- odin_model_emanators_
odin_model_hrp2_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "odin_model_hrp2_rhs_dde",
      rhs_desolve = "odin_model_hrp2_rhs_desolve",
      initmod_desolve = "odin_model_hrp2_initmod_desolve",
      output_dde = "odin_model_hrp2_output_dde"),
    dll = "ICDMM",
    user = c("aD", "age", "age_20_factor", "age_rate", "age05", "age20l",
             "age20u", "age59", "b0", "b1", "betaL", "bites_Bed",
             "bites_Indoors", "cD", "chi", "cT", "cU", "d_IRS0", "d_ITN0",
             "d1", "dB", "dCA", "dCM", "dE", "dEL", "delayGam", "delayMos",
             "den", "dID", "dLL", "dPL", "eta", "fD0", "foi_age", "ft",
             "gamma1", "gammaD", "gammaL", "het_wt", "hrp2_prop", "IB0",
             "IC0", "ID0", "init_A", "init_D", "init_EL", "init_Ev",
             "init_IB", "init_ICA", "init_ICM", "init_ID", "init_Iv",
             "init_LL", "init_P", "init_PL", "init_S", "init_Sv", "init_T",
             "init_U", "irs_cov", "IRS_interval", "irs_loss", "itn_cov",
             "ITN_interval", "ITN_IRS_on", "itn_loss", "kB", "kC", "kD",
             "mu0", "muEL", "muLL", "muPL", "mv0", "na", "nh", "num_int",
             "omega", "p10", "p2", "phi0", "phi1", "pi", "PM", "Q0",
             "r_IRS0", "r_ITN0", "r_ITN1", "rA", "rD", "rel_foi", "rP", "rT",
             "rU", "ssa0", "ssa1", "ssa2", "ssa3", "ssb1", "ssb2", "ssb3",
             "tau1", "tau2", "theta_c", "uB", "uCA", "uD", "x_I"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("odin_model_hrp2_rhs_dde", package = "ICDMM")
        .C("odin_model_hrp2_rhs_desolve", package = "ICDMM")
        .C("odin_model_hrp2_initmod_desolve", package = "ICDMM")
        .C("odin_model_hrp2_output_dde", package = "ICDMM")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("odin_model_hrp2_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "ICDMM")
    },

    update_metadata = function() {
      meta <- .Call("odin_model_hrp2_metadata", private$ptr,
                    PACKAGE = "ICDMM")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("odin_model_hrp2_create", user, PACKAGE = "ICDMM")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/odin_model_hrp2.json", mustWork = TRUE,
                             package = "ICDMM")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("odin_model_hrp2_set_user", private$ptr, user, PACKAGE = "ICDMM")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("odin_model_hrp2_initial_conditions", private$ptr, t, PACKAGE = "ICDMM")
    },

    rhs = function(t, y) {
      .Call("odin_model_hrp2_rhs_r", private$ptr, t, y, PACKAGE = "ICDMM")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("odin_model_hrp2_contents", private$ptr, PACKAGE = "ICDMM")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_delay(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


odin_model_hrp2 <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("odin_model_hrp2")
  odin_model_hrp2_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(odin_model_hrp2) <- "odin_generator"
attr(odin_model_hrp2, "generator") <- odin_model_hrp2_
odin_model_IVM_SMChet_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "odin_model_IVM_SMChet_rhs_dde",
      rhs_desolve = "odin_model_IVM_SMChet_rhs_desolve",
      initmod_desolve = "odin_model_IVM_SMChet_initmod_desolve",
      output_dde = "odin_model_IVM_SMChet_output_dde"),
    dll = "ICDMM",
    user = c("aD", "age", "age_rate", "age02", "age05", "age10", "age59",
             "b0", "b1", "B2", "betaL", "bites_Bed", "bites_Indoors", "ccov",
             "cD", "chi", "cT", "cU", "d_IRS0", "d_ITN0", "d1", "dB", "dCA",
             "dCM", "dE", "dEL", "delayGam", "den", "dID", "dLL", "dPL",
             "eff_len", "eta", "fD0", "foi_age", "ft", "gamma1", "gammaD",
             "gammaL", "haz", "het_wt", "IB0", "IC0", "ID0", "init_A",
             "init_D", "init_EL", "init_Ev", "init_IB", "init_ICA",
             "init_ICM", "init_ID", "init_Iv", "init_LL", "init_P",
             "init_PL", "init_S", "init_Sv", "init_T", "init_U", "irs_cov",
             "IRS_interval", "irs_loss", "itn_cov", "ITN_interval",
             "ITN_IRS_on", "itn_loss", "ivm_cov_par", "ivm_min_age",
             "IVRM_start", "kB", "kC", "kD", "MDA_cov", "MDA_grp_prop",
             "MDA_t1", "MDA_t2", "MDA_t3", "MDA_t4", "MDA_t5", "MDA_t6",
             "MDA_t7", "MDA_t8", "mu0", "muEL", "muLL", "muPL", "mv0", "na",
             "ncc", "nh", "num_int", "omega", "p10", "p2", "phi0", "phi1",
             "pi", "Q0", "r_IRS0", "r_ITN0", "r_ITN1", "rA", "rD", "rel_foi",
             "rP", "rT", "rU", "SMCyrs", "ssa0", "ssa1", "ssa2", "ssa3",
             "ssb1", "ssb2", "ssb3", "tau1", "tau2", "theta_c", "ttt", "uB",
             "uCA", "uD", "x_I"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("odin_model_IVM_SMChet_rhs_dde", package = "ICDMM")
        .C("odin_model_IVM_SMChet_rhs_desolve", package = "ICDMM")
        .C("odin_model_IVM_SMChet_initmod_desolve", package = "ICDMM")
        .C("odin_model_IVM_SMChet_output_dde", package = "ICDMM")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("odin_model_IVM_SMChet_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "ICDMM")
    },

    update_metadata = function() {
      meta <- .Call("odin_model_IVM_SMChet_metadata", private$ptr,
                    PACKAGE = "ICDMM")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("odin_model_IVM_SMChet_create", user, PACKAGE = "ICDMM")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/odin_model_IVM_SMChet.json", mustWork = TRUE,
                             package = "ICDMM")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("odin_model_IVM_SMChet_set_user", private$ptr, user, PACKAGE = "ICDMM")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("odin_model_IVM_SMChet_initial_conditions", private$ptr, t, PACKAGE = "ICDMM")
    },

    rhs = function(t, y) {
      .Call("odin_model_IVM_SMChet_rhs_r", private$ptr, t, y, PACKAGE = "ICDMM")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("odin_model_IVM_SMChet_contents", private$ptr, PACKAGE = "ICDMM")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_delay(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


odin_model_IVM_SMChet <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("odin_model_IVM_SMChet")
  odin_model_IVM_SMChet_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(odin_model_IVM_SMChet) <- "odin_generator"
attr(odin_model_IVM_SMChet, "generator") <- odin_model_IVM_SMChet_
odin_model_metapop_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "odin_model_metapop_rhs_dde",
      rhs_desolve = "odin_model_metapop_rhs_desolve",
      initmod_desolve = "odin_model_metapop_initmod_desolve",
      output_dde = "odin_model_metapop_output_dde"),
    dll = "ICDMM",
    user = c("aD", "age", "age_20_factor", "age_rate", "age05", "age20l",
             "age20u", "age59", "b0", "b1", "betaL", "bites_Bed",
             "bites_Indoors", "cD", "chi", "cT", "cU", "d_IRS0", "d_ITN0",
             "d1", "dB", "dCA", "dCM", "dE", "dEL", "delayGam", "delayMos",
             "den", "dID", "dLL", "dPL", "eta", "fD0", "foi_age", "ft",
             "gamma1", "gammaD", "gammaL", "het_wt", "IB0", "IC0", "ID0",
             "init_A", "init_D", "init_EL", "init_Ev", "init_IB", "init_ICA",
             "init_ICM", "init_ID", "init_Iv", "init_LL", "init_P",
             "init_PL", "init_S", "init_Sv", "init_T", "init_U", "irs_cov",
             "IRS_interval", "irs_loss", "itn_cov", "ITN_interval",
             "ITN_IRS_on", "itn_loss", "kB", "kC", "kD", "mix", "mu0",
             "muEL", "muLL", "muPL", "mv0", "na", "nh", "np", "num_int",
             "omega", "p10", "p2", "phi0", "phi1", "pi", "PM", "Q0",
             "r_IRS0", "r_ITN0", "r_ITN1", "rA", "rD", "rel_foi", "rP", "rT",
             "rU", "ssa0", "ssa1", "ssa2", "ssa3", "ssb1", "ssb2", "ssb3",
             "tau1", "tau2", "theta_c", "uB", "uCA", "uD", "x_I"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("odin_model_metapop_rhs_dde", package = "ICDMM")
        .C("odin_model_metapop_rhs_desolve", package = "ICDMM")
        .C("odin_model_metapop_initmod_desolve", package = "ICDMM")
        .C("odin_model_metapop_output_dde", package = "ICDMM")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("odin_model_metapop_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "ICDMM")
    },

    update_metadata = function() {
      meta <- .Call("odin_model_metapop_metadata", private$ptr,
                    PACKAGE = "ICDMM")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("odin_model_metapop_create", user, PACKAGE = "ICDMM")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/odin_model_metapop.json", mustWork = TRUE,
                             package = "ICDMM")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("odin_model_metapop_set_user", private$ptr, user, PACKAGE = "ICDMM")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("odin_model_metapop_initial_conditions", private$ptr, t, PACKAGE = "ICDMM")
    },

    rhs = function(t, y) {
      .Call("odin_model_metapop_rhs_r", private$ptr, t, y, PACKAGE = "ICDMM")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("odin_model_metapop_contents", private$ptr, PACKAGE = "ICDMM")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_delay(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


odin_model_metapop <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("odin_model_metapop")
  odin_model_metapop_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(odin_model_metapop) <- "odin_generator"
attr(odin_model_metapop, "generator") <- odin_model_metapop_
odin_model_TBV_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "odin_model_TBV_rhs_dde",
      rhs_desolve = "odin_model_TBV_rhs_desolve",
      initmod_desolve = "odin_model_TBV_initmod_desolve",
      output_dde = "odin_model_TBV_output_dde"),
    dll = "ICDMM",
    user = c("aD", "age", "age_20_factor", "age_max_rts", "age_max_tbv",
             "age_min_rts", "age_min_tbv", "age_rate", "age05", "age20l",
             "age20u", "age59", "alpha_RTS", "b0", "b1", "beta_RTS", "betaL",
             "bites_Bed", "bites_Indoors", "cD", "chi", "CS_boost",
             "CS_peak", "cT", "cU", "d_IRS0", "d_ITN0", "d1", "dB", "dCA",
             "dCM", "dE", "dEL", "delayGam", "delayMos", "den", "dID", "dl",
             "dl25", "dLL", "dPL", "ds", "ds25", "eta", "fD0", "foi_age",
             "ft", "gamma1", "gammaD", "gammaL", "het_wt", "hill1", "hill2",
             "IB0", "IC0", "ID0", "init_A", "init_D", "init_EL", "init_Ev",
             "init_IB", "init_ICA", "init_ICM", "init_ID", "init_Iv",
             "init_LL", "init_P", "init_PL", "init_S", "init_Sv", "init_T",
             "init_U", "irs_cov", "IRS_interval", "irs_loss", "itn_cov",
             "ITN_interval", "ITN_IRS_on", "itn_loss", "kB", "kC", "kD",
             "mu0", "mu25", "muEL", "muLL", "muPL", "mv0", "na", "nh",
             "num_int", "omega", "p_boost", "p_peak", "p10", "p2", "phi0",
             "phi1", "pi", "PM", "Q0", "r_IRS0", "r_ITN0", "r_ITN1", "rA",
             "rD", "rel_foi", "rho25", "rP", "rT", "RTS_switch", "rU",
             "ssa0", "ssa1", "ssa2", "ssa3", "ssb1", "ssb2", "ssb3",
             "switch_TBV", "switch_TRA_to_TBA", "t_boost_rts", "tau1",
             "tau2", "tau25", "theta_c", "uB", "uCA", "uD", "v_interval",
             "V_max_RTS", "vacc_lag", "x_I"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("odin_model_TBV_rhs_dde", package = "ICDMM")
        .C("odin_model_TBV_rhs_desolve", package = "ICDMM")
        .C("odin_model_TBV_initmod_desolve", package = "ICDMM")
        .C("odin_model_TBV_output_dde", package = "ICDMM")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("odin_model_TBV_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "ICDMM")
    },

    update_metadata = function() {
      meta <- .Call("odin_model_TBV_metadata", private$ptr,
                    PACKAGE = "ICDMM")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("odin_model_TBV_create", user, PACKAGE = "ICDMM")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/odin_model_TBV.json", mustWork = TRUE,
                             package = "ICDMM")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("odin_model_TBV_set_user", private$ptr, user, PACKAGE = "ICDMM")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("odin_model_TBV_initial_conditions", private$ptr, t, PACKAGE = "ICDMM")
    },

    rhs = function(t, y) {
      .Call("odin_model_TBV_rhs_r", private$ptr, t, y, PACKAGE = "ICDMM")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("odin_model_TBV_contents", private$ptr, PACKAGE = "ICDMM")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_delay(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


odin_model_TBV <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("odin_model_TBV")
  odin_model_TBV_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(odin_model_TBV) <- "odin_generator"
attr(odin_model_TBV, "generator") <- odin_model_TBV_
